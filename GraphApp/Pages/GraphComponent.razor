@inject GraphStateService GraphState
@implements IDisposable
<div id="graph-container" style="width: 100%; height: 100%;"></div>

@inject IJSRuntime JSRuntime

@code {
    private List<Node> Nodes { get; set; } = new List<Node>();
    private List<Link> Links { get; set; } = new List<Link>();

    protected override void OnInitialized()
    {
        GraphState.OnChange += StateHasChanged;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // 1. Determine which links to render based on selected cities
        var linksToRender = GraphState.Links
            .Where(l => GraphState.SelectedCities.Contains(l.Source) || GraphState.SelectedCities.Contains(l.Target))
            .ToList();

        // 2. Determine which nodes to render:
        //    a. All explicitly selected cities
        //    b. All nodes connected by the linksToRender (even if not explicitly selected)
        var nodesToRenderIds = new HashSet<string>(GraphState.SelectedCities);
        foreach (var link in linksToRender)
        {
            nodesToRenderIds.Add(link.Source);
            nodesToRenderIds.Add(link.Target);
        }

        var nodesToRender = GraphState.Nodes
            .Where(n => nodesToRenderIds.Contains(n.Id))
            .ToList();

        if (nodesToRender.Any())
        {
            await JSRuntime.InvokeVoidAsync("renderD3Graph", "graph-container", nodesToRender, linksToRender, DotNetObjectReference.Create(this));
        }
    }

    [JSInvokable]
    public void OnLabelClicked(string nodeId)
    {
        GraphState.SelectCity(nodeId);
    }

    public void Dispose()
    {
        GraphState.OnChange -= StateHasChanged;
    }
}